
### Names 
``` OCaml
let name = expression

let x = 200;;
val x : int = 200
```

### Compound Functions
``` OCaml
let ... = ... in ...;;

let x = 200 in x * x * x;;
- : int = 8000000

let a = 500 in (let b = a * a in a + b);;
- : int = 250500
```

### Functions
Functions depend on some input (**arguments**)
``` OCaml
# let cube x = x * x * x;;
val cube : int -> int = <fun>
# cube 200;;
- : int = 8000000
```

Arguments of the wrong type will be rejected:
``` ocaml
# let cube x = x * x * x;;
val cube : int => int = <fun>
# cube false;;
Error: This expression has type bool but an expression was expected of type int
```

Another example:
``` Ocaml
# let neg x = if x < 0;;
val neg : int -> bool = <fun>
# neg (-30);;
- : bool = true
```

Vowel example:
``` ocaml
# let isvowel c = 
	c = 'a' || c = 'e' || c = 'i' || c = 'o' || c = 'u';;
val isvowel : char -> bool = <fun>
# isvowel 'x';;
val bool = false
```

Multiple Arguments:
``` ocaml
# let addtoten a b = 
	a + b = 10;;
val isvowel : int -> int -> bool = <fun>
# addtoten 6 4;;
- : bool = true
```
The type is `int -> int -> bool` because the arguments are both integers, and the result is a boolean.

### Recursive functions
